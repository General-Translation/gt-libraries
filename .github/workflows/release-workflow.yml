name: Prepare Releases

on:
  push:
    branches:
      - main
    paths:
      - 'packages/**'
  workflow_dispatch:
    inputs:
      package:
        description: 'Package directory name (under packages/)'
        required: false
        type: string
      release_type:
        description: 'Release type'
        required: false
        default: 'patch'
        type: choice
        options:
          - patch
          - minor
          - major
      npm_tag:
        description: 'NPM tag (overrides automatic detection)'
        required: false
        type: choice
        options:
          - auto
          - latest
          - alpha
          - beta
          - rc
        default: 'auto'

jobs:
  release-please:
    name: Release Please
    runs-on: ubuntu-latest
    outputs:
      releases_created: ${{ steps.release.outputs.releases_created }}
      paths_released: ${{ steps.release.outputs.paths_released }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check for manual package selection
        id: check-manual
        if: github.event_name == 'workflow_dispatch' && github.event.inputs.package != ''
        run: |
          echo "Manually selected package: ${{ github.event.inputs.package }}"
          echo "Using release type: ${{ github.event.inputs.release_type || 'patch' }}"

      - name: Release Please
        id: release
        uses: googleapis/release-please-action@v4
        with:
          token: ${{ secrets.GH_PAT }}
          command: ${{ github.event.inputs.release_type != '' && 'release-pr' || github.event_name == 'workflow_dispatch' && 'release-pr' || 'manifest' }}
          default-branch: main
          config-file: release-please-config.json
          manifest-file: .release-please-manifest.json
          release-type: node
          package-name: ${{ github.event.inputs.package != '' && format('@gt-libraries/{0}', github.event.inputs.package) || '' }}
          path: ${{ github.event.inputs.package != '' && format('packages/{0}', github.event.inputs.package) || '' }}
          monorepo-tags: true
          debug: true

  publish:
    name: Publish Packages
    needs: [release-please]
    if: needs.release-please.outputs.releases_created == 'true'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: main # Make sure we're on the main branch with the newly created release tags

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          registry-url: 'https://registry.npmjs.org'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Build package
        run: npm run build

      - name: Determine release tag
        id: release-tag
        run: |
          MANUAL_TAG="${{ github.event.inputs.npm_tag }}"
          
          # Default to latest tag
          NPM_TAG="latest"
          
          # Use manually specified tag if provided and not "auto"
          if [[ "$MANUAL_TAG" != "" && "$MANUAL_TAG" != "auto" ]]; then
            NPM_TAG="$MANUAL_TAG"
            echo "Using manually specified npm tag: $NPM_TAG"
          else
            echo "Using default tag: $NPM_TAG"
          fi
          
          echo "npm_tag=$NPM_TAG" >> $GITHUB_OUTPUT
          echo "Release created: ${{ needs.release-please.outputs.releases_created }}"

      - name: List packages for publishing
        id: list-packages
        run: |
          # If a specific package was released via manual workflow
          if [[ -n "${{ github.event.inputs.package }}" ]]; then
            PKG_DIR="packages/${{ github.event.inputs.package }}"
            if [[ -f "$PKG_DIR/package.json" ]]; then
              echo "Found package $PKG_DIR for publishing"
              echo "packages=$PKG_DIR" >> $GITHUB_OUTPUT
            else
              echo "Package $PKG_DIR not found"
              exit 1
            fi
          else
            # For automatic detection, look for packages with new tags
            PACKAGES=""
            for PKG_DIR in packages/*/; do
              if [[ -f "$PKG_DIR/package.json" ]]; then
                PKG_NAME=$(node -p "require('./$PKG_DIR/package.json').name")
                echo "Checking package $PKG_NAME for new releases..."
                
                # If it was released, it should have a tag matching the release
                LATEST_TAG=$(git tag -l "$PKG_NAME@*" | sort -V | tail -n1)
                if [[ -n "$LATEST_TAG" ]]; then
                  # Check if this tag was just created (in the last 5 minutes)
                  TAG_DATE=$(git log -1 --format=%at "$LATEST_TAG")
                  NOW=$(date +%s)
                  
                  # If the tag is newer than 5 minutes, consider it as just released
                  if (( NOW - TAG_DATE < 300 )); then
                    echo "Found recently released package: $PKG_NAME"
                    PACKAGES="${PACKAGES}${PKG_DIR},"
                  fi
                fi
              fi
            done
            
            # Remove trailing comma
            PACKAGES=${PACKAGES%,}
            echo "packages=$PACKAGES" >> $GITHUB_OUTPUT
            echo "Packages to publish: $PACKAGES"
          fi

      - name: Publish to npm
        if: steps.list-packages.outputs.packages != ''
        run: |
          PACKAGES="${{ steps.list-packages.outputs.packages }}"
          IFS=',' read -ra PKG_DIRS <<< "$PACKAGES"
          
          echo "Publishing packages"
          
          for PKG_DIR in "${PKG_DIRS[@]}"; do
            if [[ -f "$PKG_DIR/package.json" ]]; then
              PKG_NAME=$(node -p "require('./$PKG_DIR/package.json').name")
              echo "Publishing $PKG_NAME with tag ${{ steps.release-tag.outputs.npm_tag }}"
              cd $PKG_DIR
              npm publish --access public --tag ${{ steps.release-tag.outputs.npm_tag }}
              cd - > /dev/null
            fi
          done
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
